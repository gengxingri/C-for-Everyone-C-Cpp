/*
   Assignment 3 - honor

   Modify the singly linked list to be a doubly linked list. 
   Removes all duplicate data in the doubly linked list. 
   The data will be integers generated by 200 random from [0,49].  
   Sort the list by its data field and then remove adjacent elements with the same value

*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#define SIZE 200

// define the struct list
typedef struct list{ int data; struct list *next; struct list *pre;}list;

// return 1 or 0 based on whether or not argument list is empty
int is_empty(const list *l){ return (l == NULL);}

// creat a node (head) of a list
list *create_list(int d){
    list *head = malloc(sizeof(list));
    head -> data = d;
    head -> next = NULL;
    head ->pre = NULL;
    return head;
}

// add a node (head) to a list and return a node (head)
list *add_to_front(int d, list *h){
    list *head = create_list(d);
    head -> next = h;
    h -> pre = head;
    return head;
}

// creat a link list from an array and return a node (head)
list *array_to_list(int d[], int size){
    list *head = create_list(d[0]);
    int i;
    for(i = 1; i< size; i++){
        head = add_to_front(d[i], head);
    }
    return head;
}

// print the title of parameter list, followed by as line of this list's elements
void print_list(list *h, char *title){

    printf("%s\n", title);
    int i = 0;
    while(h != NULL){
        if(i != SIZE-1)
            printf("%d\t", h->data);

        // break line every five elements
        if ((i % 5) == 4){printf("\n");}

        // move h to the next node, increment i.
        h = h -> next;
        i++;
    }
    printf("\n\n");
}

// swap the data of two given pointers
void swap_nodes(list *p1, list *p2){
    int temp = p1->data;
    p1->data = p2->data;
    p2->data = temp;
    return;
}

/* Bubble sort to sort a given list
   Consider two adjacent pointers and start at the beggining of the list. 
*/

void sort_list(list *h){
    int i, j;
    list *p1, *p2;

    //
    for(i = SIZE-2; i >= 0; i--){
        p1 = h;
        p2 = p1->next;
        for(j = 0; j <= i; j++){
            if(p1->data > p2->data)
                swap_nodes(p1, p2);
            p1 = p2;
            p2 = p2->next;
        }
    }

}

// remove argument node from the list
void remove_node(list *node){
    if(node != NULL){

        // If the element we want to remove is the only element in the list
        if(node -> pre == NULL && node->next == NULL){
            node = NULL;
            return;
        }

        // If the element we want to remove is the head of the list
        else if(node->pre == NULL){
            list *my_next = node->next;
            node->next = NULL;
            my_next->pre = NULL;
            return;
        }

        // If the element we want to remove is the last element in the list
        else if(node->next == NULL){
            list *my_pre = node->pre;
            node->pre = NULL;
            my_pre->next = NULL;
            return;
        }

        else{
            list *my_pre = node->pre;
            list *my_next = node->next;
            node -> next = NULL;
            node -> pre = NULL;
            my_pre -> next = my_next;
            my_next -> pre = my_pre;
            return;
        }

    }
}

// remove duplicate values from the list
void remove_dups(list *h){
    while (h->next != NULL){

        // For teo equal datas, remove it.
        if (h->data == h->next->data){
            remove_node(h->next);
        }
        else
            // For two different datas, push the pointer one step forward
            h = h->next;
    }
}



// Main function
int main(void){

    list *l = create_list(rand()%49); // start the list with a random numbers
    int i;
    for(i = 0; i < SIZE-1; i++){
        l = add_to_front(rand()%49, l);
    }                                 // add (size-1) new elements to the list

    print_list(l, "200 random numbers:");
    sort_list(l);
    print_list(l, "After Sorting: ");
    remove_dups(l);
    print_list(l, "After removal: ");
    return 0;
    
}












